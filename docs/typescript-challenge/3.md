# TypeScript å¤§æŒ‘æˆ˜ï¼ˆä¸‰ï¼‰

è¿™æ˜¯ TypeScript å¤§æŒ‘æˆ˜ç³»åˆ—çš„ç¬¬ 3 ç¯‡ï¼Œç¬”è€…è®¡åˆ’ç”¨ 6 ä¸ªæœˆæ—¶é—´å®Œæˆ [type-challenges](https://github.com/type-challenges/type-challenges "type-challenges") é¡¹ç›®ä¸­çš„ 133 ä¸ªæŒ‘æˆ˜å¹¶è®°å½•ä¸‹è‡ªå·±çš„æ”¶è·ï¼Œç›®å‰è¿˜å‰©ä½™ 127 ä¸ªï¼Œæˆªæ­¢æ—¥æœŸä¸º 2023 å¹´ 1 æœˆ25 æ—¥ã€‚


![æŒ‘æˆ˜è¿›åº¦](./public/2-progress.png)

## 7. Awaited

### æŒ‘æˆ˜å†…å®¹

å‡å¦‚æˆ‘ä»¬æœ‰ä¸€ä¸ª Promise å¯¹è±¡ï¼Œè¿™ä¸ª Promise å¯¹è±¡ä¼šè¿”å›ä¸€ä¸ªç±»å‹ã€‚åœ¨ TS ä¸­ï¼Œæˆ‘ä»¬ç”¨ Promise ä¸­çš„ T æ¥æè¿°è¿™ä¸ª Promise è¿”å›çš„ç±»å‹ã€‚è¯·ä½ å®ç°ä¸€ä¸ªç±»å‹å·¥å…·ï¼Œå¯ä»¥è·å–è¿™ä¸ªç±»å‹ã€‚

ä¾‹å¦‚ï¼š`Promise<Type>`ï¼Œè¯·ä½ è¿”å› `Type` ç±»å‹ã€‚

``` typescript
// TODO: å®ç° MyAwaited
type MyAwaited = any;

// Result1 ä¸º string
type Type1 = Promise<string>
type Result1 = MyAwaited<Type1>

// æ”¯æŒ Promise åµŒå¥—ï¼ŒResult2 ä¸º string
type Type2 = Promise<Promise<string>>
type Result2 = MyAwaited<Type2>

// ä¼ å…¥é Promise å¯¹è±¡ï¼ŒæŠ›å‡ºé”™è¯¯
type Result3 = MyAwaited<string>
```

> çŸ¥è¯†ç‚¹ï¼š`infer / é€’å½’è°ƒç”¨`

### é¢˜ç›®è§£æ

é¢˜ç›®ä¸­æœ‰ä¸¤ä¸ªåœ°æ–¹éœ€è¦ç‰¹åˆ«å…³æ³¨ï¼š

1. å¯¹äº Promise åµŒå¥—çš„æƒ…å†µï¼Œè¦èƒ½å¤Ÿå–å‡ºæœ€é‡Œå±‚çš„æ•°æ®ç±»å‹ï¼Œä¾‹å¦‚å¯¹äº `Promise<Promise<string>>` ç±»å‹ï¼Œåº”è¯¥æ‹¿åˆ° `string`ã€‚
2. å½“ä¼ å…¥é Promise ç±»å‹çš„æ—¶å€™ï¼Œåº”è¯¥æŠ¥é”™æ–¹ä¾¿æå‰å‘ç°é—®é¢˜ã€‚

é¦–å…ˆä¸è€ƒè™‘è¿™ä¸¤ä¸ªç‰¹æ®Šç‚¹ï¼Œä»æœ€ç®€å•çš„æƒ…å†µå…¥æ‰‹ã€‚

ä¸ºäº†å–å‡º Promise åŒ…è£¹çš„ç±»å‹ï¼Œéœ€è¦ä½¿ç”¨åœ¨å¤§æŒ‘æˆ˜ï¼ˆäºŒï¼‰ä¸­ä»‹ç»åˆ°çš„ `infer`ï¼Œå¯ä»¥å®ç°å¦‚ä¸‹æœ€ç®€å•çš„ç‰ˆæœ¬ï¼š

``` typescript
type MyAwaited<T>
  = T extends Promise<infer K> ? K : never
```

æ¥ä¸‹æ¥è€ƒè™‘å¦‚ä½•å¤„ç†åµŒå¥—çš„æƒ…å†µã€‚å¹³æ—¶æˆ‘ä»¬åœ¨å†™æ™®é€š JavaScript ä»£ç çš„æ—¶å€™ï¼Œä¸»è¦æ˜¯é€šè¿‡é€’å½’è°ƒç”¨å’Œå¾ªç¯ä¸¤ç§æ–¹å¼æ¥å¤„ç†åµŒå¥—çš„æƒ…å†µï¼Œç„¶è€Œåœ¨ TypeScript ä¸­å£°æ˜ Type ç±»å‹çš„æ—¶å€™ï¼Œæ²¡æœ‰åŠæ³•ä½¿ç”¨å¾ªç¯ï¼Œæ‰€ä»¥**ä¸»è¦æ˜¯é€šè¿‡é€’å½’è°ƒç”¨å¤„ç†åµŒå¥—**ï¼Œå¯¹äº `infer K` æ¨æ–­å‡ºæ¥çš„ç±»å‹ Kï¼Œåˆ¤æ–­æ˜¯å¦ä¸º Promiseï¼Œè‹¥æ˜¯çš„è¯åˆ™å°†å®ƒå¸¦å…¥ `MyAwaited<K>` å†è®¡ç®—ä¸€éï¼š
ï¼š

``` typescript
type MyAwaited<T>
  = T extends Promise<infer K>
    ? (K extends Promise<any> ? MyAwaited<K> : K)
    : never
```

æœ€åæ¥å¤„ç†å½“ä¼ å…¥çš„ç±»å‹ä¸æ˜¯ Promise æ—¶åº”è¯¥æŠ›å‡ºé”™è¯¯çš„é—®é¢˜ï¼Œä¸€å¼€å§‹ä¼šè§‰å¾—æ²¡æœ‰å¤´ç»ªï¼Œå› ä¸ºæ²¡æœ‰ä¸»åŠ¨æŠ›å‡ºé”™è¯¯çš„æ–¹æ³•ï¼Œä½†æ˜¯è½¬å¿µä¸€æƒ³å…¶å®å¾ˆç®€å•ï¼šå£°æ˜ T æ˜¯ Promise ç±»å‹åï¼ŒTypeScript ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨æ£€æŸ¥ç±»å‹å¹¶æŠ¥é”™ï¼š

``` typescript
type MyAwaited<T extends Promise<any>>
  = ...
```

### é¢˜ç›®ç­”æ¡ˆ

``` typescript
type MyAwaited<T extends Promise<any>>
  = T extends Promise<infer K>
    ? (K extends Promise<any> ? MyAwaited<K> : K)
    : never
```

> é¢å¤–æ€è€ƒï¼šå°†ç­”æ¡ˆä¸­çš„ä¸¤ä¸ª `any` æ›¿æ¢æˆ `unknown` ä¹Ÿæ˜¯æ­£ç¡®çš„ï¼Œå¤§å®¶çŸ¥é“ä»–ä»¬ä¿©ä¸ªçš„åŒºåˆ«å—ï¼Ÿ

## 8. If

### æŒ‘æˆ˜å†…å®¹

å®ç°ä¸€ä¸ª `If` ç±»å‹ï¼Œå®ƒæ¥æ”¶ä¸€ä¸ªæ¡ä»¶ç±»å‹ `C` ï¼Œä¸€ä¸ªåˆ¤æ–­ä¸ºçœŸæ—¶çš„è¿”å›ç±»å‹ `T` ï¼Œä»¥åŠä¸€ä¸ªåˆ¤æ–­ä¸ºå‡æ—¶çš„è¿”å›ç±»å‹ `F`ã€‚ `C` åªèƒ½æ˜¯ `true` æˆ–è€… `false`ï¼Œ `T` å’Œ `F` å¯ä»¥æ˜¯ä»»æ„ç±»å‹ã€‚

``` typescript
// TODO: å®ç° If
type If<C, T, F> = any

// A ä¸º 'a'
type A = If<true, 'a', 'b'>

// B ä¸º 'b'
type B = If<false, 'a', 'b'>

// ä¼ å…¥çš„ä¸æ˜¯ true / falseï¼ŒæŠ›å‡ºé”™è¯¯
type error = If<null, 'a', 'b'>
```

### é¢˜ç›®è§£æ

è¿™ä¸ªé¢˜ç›®æ¯”è¾ƒç®€å•ï¼Œå…³é”®ç‚¹åœ¨äºå¦‚ä½•åˆ¤æ–­ `C` ä¸º `true / false`ã€‚

å…¶å®å¯¹äº `true / false`ï¼Œç”šè‡³ `1 / 2 / null / undefined / 'hello'` è¿™äº›åŸºæœ¬ç±»å‹çš„å˜é‡ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ `extends` åˆ¤æ–­ï¼š

``` typescript
// Bool1 ä¸º 1
type Bool1 = true extends true ? 1 : 0

// Bool2 ä¸º 1
type Bool2 = false extends false ? 1 : 0

// Number1 ä¸º 1
type Number1 = 1 extends 1 ? 1 : 0

// String1 ä¸º 1
type String1 = 'hello' extends 'hello' ? 1 : 0
```

### é¢˜ç›®ç­”æ¡ˆ

å’Œä¸Šä¸€é¢˜ç±»ä¼¼ï¼Œä¹ŸåŠ ä¸Š `C extends boolean` çš„é™åˆ¶ï¼Œè¿™æ ·å½“ `C` ä¸æ˜¯ `true/false` çš„æ—¶å€™ç¼–è¯‘å™¨ä¼šæŠ›å‡ºé”™è¯¯ï¼š

``` typescript
type If<C extends boolean, T, F>
  = C extends true ? T : F;
```

## 9. Concat

### æŒ‘æˆ˜å†…å®¹

åœ¨ç±»å‹ç³»ç»Ÿé‡Œå®ç° JavaScript å†…ç½®çš„ `Array.concat` æ–¹æ³•ï¼Œè¿™ä¸ªç±»å‹æ¥å—ä¸¤ä¸ªå‚æ•°ï¼Œè¿”å›çš„æ–°æ•°ç»„ç±»å‹åº”è¯¥æŒ‰ç…§è¾“å…¥å‚æ•°ä»å·¦åˆ°å³çš„é¡ºåºåˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„æ•°ç»„ã€‚

``` typescript
// TODO: å®ç° Concat
type Concat<T, U> = any

// Result1 ä¸º [1, 2]
type Result1 = Concat<[1], [2]>
```

### é¢˜ç›®è§£æ

è¿™ä¸ªé¢˜ç›®åŒæ ·æ¯”è¾ƒç®€å•ï¼Œåªè¦æˆ‘ä»¬äº†è§£åˆ°åœ¨ç±»å‹ç³»ç»Ÿä¸­ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ `...array` çš„æ–¹å¼æ¥å–å‡ºæ•°ç»„ç±»å‹çš„å…¨éƒ¨å…ƒç´ å³å¯ï¼š

``` typescript
// å®šä¹‰å…ƒç»„ç±»å‹
type Array1 = [1, 2]

// A ä¸º [1, 2]ï¼Œå…ƒç»„ç±»å‹å¯ä»¥ç›´æ¥éå†
type A = [...Array1]

// å®šä¹‰å¸¸é‡æ•°ç»„
const array2 = [1, 2] as const

// B ä¸º [1, 2]ï¼Œå¸¸é‡æ•°ç»„çš„ç±»å‹å¯ä»¥ç›´æ¥éå†
type B = [...typeof array2]
```

### é¢˜ç›®ç­”æ¡ˆ

``` typescript
type Concat<
  T extends any[],
  U extends any[]
> = [...T, ...U]
```

## 10. Includes

### æŒ‘æˆ˜å†…å®¹

åœ¨ç±»å‹ç³»ç»Ÿé‡Œå®ç° JavaScript çš„ `Array.includes` æ–¹æ³•ï¼Œè¿™ä¸ªç±»å‹æ¥å—ä¸¤ä¸ªå‚æ•°ï¼Œè¿”å›çš„ç±»å‹è¦ä¹ˆæ˜¯ `true` è¦ä¹ˆæ˜¯ `false`ã€‚

``` typescript
// TODO: å®ç° Includes
type Includes<
  T extends readonly any[],
  U,
> = any

// is1 ä¸º true
type is1 = Includes<[1, 2], 1>

// is2 ä¸º false
type is2 = Includes<[1, 2], 3>

// is3 ä¸º false
type is3 = Includes<[1, 2], 1 | 2>
```

### é¢˜ç›®è§£æ

è¿™ä¸ªé¢˜ç›®ä¹Ÿæ¶‰åŠåˆ°äº†å¾ªç¯åˆ¤æ–­çš„åœºæ™¯ï¼šéœ€è¦å–å‡ºæ•°ç»„ `T` ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ ï¼Œåˆ¤æ–­æ˜¯å¦ç­‰äº `U`ã€‚å¯¹äºè¿™æ ·çš„åœºæ™¯ï¼Œå¯ä»¥å¥—ç”¨ `7. Awaited` ä½¿ç”¨çš„é€’å½’è°ƒç”¨æ–¹å¼ï¼š

``` typescript
type Includes<
  T extends readonly any[],
  U,
> = T extends [infer First, ...infer Rest]
  ? ((First ç­‰äº U) ? true : Includes<Rest, U>)
  : false
```

é€’å½’è°ƒç”¨çš„æ¡†æ¶æ­èµ·æ¥åå°±é€»è¾‘å°±å¾ˆæ¸…æ™°äº†ï¼š

1. å…ˆå–å‡ºæ•°ç»„ `T` çš„ç¬¬ä¸€ä¸ªå…ƒç´  `First`ï¼›
2. å¦‚æœ `First` å’Œ `U` ç›¸ç­‰ï¼Œåˆ™è¿”å› `true`ï¼›
3. å¦‚æœ `Frist` å’Œ `U` ä¸ç›¸ç­‰ï¼Œåˆ™å–å‡ºå‰©ä¸‹å…ƒç´ ç»„æˆçš„æ•°ç»„ `Rest`ï¼›
4. å¦‚æœ `Rest` ä¸ä¸ºç©ºï¼Œåˆ™å¸¦å…¥ç¬¬ 1 æ­¥å†æ¬¡åˆ¤æ–­ï¼›
5. å¦‚æœ `Rest` ä¸ºç©ºï¼Œåˆ™è¿”å› `false`ã€‚

ç°åœ¨å‰©ä¸‹çš„é—®é¢˜å°±æ˜¯å¦‚ä½•åˆ¤æ–­ `First` æ˜¯å¦ç­‰äº `U`ã€‚

å…ˆæ¥å®ç°ä¸€ä¸ªåŸºç¡€ç‰ˆæœ¬ `EqualV1`ã€‚

åœ¨ `8. If` ä¸­è¯´è¿‡å¯¹äºåŸºæœ¬æ•°æ®ç±»å‹ï¼Œå¯ä»¥é€šè¿‡ `extends` åˆ¤æ–­ä¸¤ä¸ªç±»å‹æ˜¯å¦ç›¸ç­‰ï¼Œä¾‹å¦‚å¯¹äºç±»å‹ T å’Œ Kï¼Œç®€å•æƒ…å†µä¸‹è‹¥ `T extends K` ä¸” `K extends T`ï¼Œå¯ä»¥è¯´ T ç­‰äº Kï¼š

``` typescript
type EqualV1<T, K>
  = T extends K
    ? (K extends T ? true : false)
    : false

// A ä¸º true
type A = EqualV1<true, true>

// B ä¸º false
type B = EqualV1<1, 2>

// C ä¸º false
type C = EqualV1<'hello', 1>

// D ä¸º trueï¼Œ
// ä½†æ˜¯ {a: 1} å’Œ {readonly a: 1} ä¸ç­‰
type D = EqualV1<
  { a: 1 },
  { readonly a: 1 }
>
```

ä¹‹æ‰€ä»¥ `D` æ˜¯ trueï¼Œæ˜¯å› ä¸º TypeScript ç¼–è¯‘å™¨åœ¨åˆ¤æ–­ä¸¤ä¸ªç±»å‹æ˜¯å¦æ»¡è¶³ `T extends K` æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å½¢è±¡ç†è§£ä¸ºç±»å‹ `K` çš„å˜é‡æ˜¯å¦å¯ä»¥èµ‹å€¼ç»™ç±»å‹ `T` çš„å˜é‡ï¼Œè€Œå¯¹äºå¯¹è±¡å˜é‡è€Œè¨€ï¼Œ `readonly` ç­‰å±æ€§ä¿®é¥°çš„æƒ…å†µä¸‹éƒ½æ˜¯å¯ä»¥äº’ç›¸èµ‹å€¼çš„ï¼š

``` typescript
type A = { a: number }
type ReadonlyA = { readonly a: number }

const a1: A = { a: 1 }
const a2: ReadonlyA = { a: 2 }

// ReadonlyA ç±»å‹å˜é‡å¯ä»¥èµ‹å€¼ç»™ A ç±»å‹
const a3: A = a2;

// A ç±»å‹å˜é‡ä¹Ÿå¯ä»¥èµ‹å€¼ç»™ ReadonlyA ç±»å‹
const a4: ReadonlyA = a1;
```

ä¸ºäº†è§£å†³ `EqualV1` å¯¹äº `readonly` å±æ€§ä¿®é¥°çš„å¯¹è±¡åˆ¤æ–­ä¸å‡†çš„é—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ç‚¹å¥‡æŠ€æ·«å·§ï¼š

``` typescript
type EqualV2<A,B>
    =(<T>() => T extends A ? 1 : 0) extends
      (<T>() => T extends B ? 1 : 0)
      ? true : false;
```

è¿™æ˜¯æ¥è‡ª [Github - type level equal operator](https://github.com/Microsoft/TypeScript/issues/27024#issuecomment-421529650 "Github - type level equal operator") çš„æ–¹æ³•ï¼Œç‰›å•ŠğŸ‘ã€‚

åŸç†æ˜¯å½“æ¡ä»¶ç±»å‹ä¸­çš„ `T` æœªçŸ¥æ—¶ï¼Œä¼šå»¶è¿Ÿåˆ°è°ƒç”¨æ—¶è¿›è¡Œåˆ¤æ–­ï¼Œåˆ¤æ–­æ—¶ä¼šè°ƒç”¨ TypeScript å†…éƒ¨çš„ `isTypeIdenticalTo` æ–¹æ³•ï¼Œå½“ä¸”ä»…å½“ä¸¤ä¸ªæ¡ä»¶ç±»å‹æ»¡è¶³å¦‚ä¸‹æ¡ä»¶æ—¶è¿”å› `true`ï¼š

- ä¸¤ä¸ªæ¡ä»¶ç±»å‹çš„çº¦æŸï¼ˆconstraintï¼‰ç›¸åŒ
- ä¸¤ä¸ªæ¡ä»¶ç±»å‹çš„ true / false åˆ†æ”¯å€¼ç›¸åŒ


### é¢˜ç›®ç­”æ¡ˆ
``` typescript
type Equal<A,B>
    =(<T>() => T extends A ? 1 : 0) extends
      (<T>() => T extends B ? 1 : 0)
      ? true : false
    
type Includes<
  T extends readonly any[],
  U,
> = T extends [infer First, ...infer Rest]
  ? (Equal<First, U> extends true ? true : Includes<Rest, U>)
  : false
```

## ç»“è¯­

è¿™ä¸€æ¬¡çš„æŒ‘æˆ˜åˆ°æ­¤å°±ç»“æŸå•¦ï¼Œæœ€å¤§çš„æ”¶è·å°±æ˜¯é€šè¿‡ `7. Awaited` å’Œ `10. Includes` è¿™ä¸¤é“é¢˜ç›®ï¼Œå¯ä»¥æ€»ç»“å‡ºå¦‚ä¸‹é€’å½’è°ƒç”¨è§£å†³åµŒå¥—é—®é¢˜å’Œæ•°ç»„éå†é—®é¢˜çš„æ¨¡æ¿ï¼š

``` typescript
type Solution<
  T extends readonly any[],
> = T extends [infer First, ...infer Rest]
  ? (First æ»¡è¶³è¦æ±‚ ? true : Solution<Rest, U>)
  : false
```

